name: GitLab Release Checker
# Ensure Proper Permissions for the Workflow Token
permissions:
  contents: write
  actions: write

on:
  schedule:
    - cron: '0 2,14 * * *'
  workflow_dispatch:

jobs:
  check-new-release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3
        with:
          ref: main

      - name: Get GitLab Docker tags with last modified date
        id: fetch-tags
        run: |
          # Fetch own tags (only full image with "ce.0" suffix)
          curl -s "https://hub.docker.com/v2/repositories/feskol/gitlab/tags?page_size=100" | jq -r '.results[].name' | grep -E "^[0-9]+\.[0-9]+\.[0-9]+-(ce|ee)\.0$" > own_tags.txt
          
          # Fetch both ce and ee tags (tag name and last updated date)
          curl -s "https://hub.docker.com/v2/namespaces/gitlab/repositories/gitlab-ce/tags?page_size=100" | jq -r '[.results[] | {name: .name, last_updated: .last_updated}]' > gitlab_tags_ce.json
          curl -s "https://hub.docker.com/v2/namespaces/gitlab/repositories/gitlab-ee/tags?page_size=100" | jq -r '[.results[] | {name: .name, last_updated: .last_updated}]' > gitlab_tags_ee.json

      - name: Get latest major version
        id: major-version
        run: |
          # Extract the tags from the JSON data, filter based on the pattern, and sort them by version number (major, minor, patch).
          jq -r '.[] | select(.name | test("^[0-9]+\\.[0-9]+\\.[0-9]+-ce\\.0$")) | .name' gitlab_tags_ce.json | sort -V | tail -n 1  > latest_ce_tag.txt
          jq -r '.[] | select(.name | test("^[0-9]+\\.[0-9]+\\.[0-9]+-ee\\.0$")) | .name' gitlab_tags_ee.json | sort -V | tail -n 1 > latest_ee_tag.txt
          
          # Strip version-specific parts to generate base tags
          BASE_TAG_CE=$(cat latest_ce_tag.txt | sed -E "s/-ce.0$//")
          BASE_TAG_EE=$(cat latest_ee_tag.txt | sed -E "s/-ee.0$//")
          
          # Read the highest version tag
          LATEST_MAJOR_CE=$(echo "$BASE_TAG_CE" | cut -d. -f1)
          LATEST_MAJOR_EE=$(echo "$BASE_TAG_EE" | cut -d. -f1)
          
          echo "LATEST_MAJOR_CE=$LATEST_MAJOR_CE" >> $GITHUB_OUTPUT
          echo "LATEST_MAJOR_EE=$LATEST_MAJOR_EE" >> $GITHUB_OUTPUT
          
          # Output major
          echo "CE latest major: $LATEST_MAJOR_CE"
          echo "EE latest major: $LATEST_MAJOR_EE"
          
          # Read the highest major.minor
          LATEST_MAJOR_MINOR_CE=$(echo "$BASE_TAG_CE" | cut -d. -f1-2)
          LATEST_MAJOR_MINOR_EE=$(echo "$BASE_TAG_EE" | cut -d. -f1-2)
          
          echo "LATEST_MAJOR_MINOR_CE=$LATEST_MAJOR_MINOR_CE" >> $GITHUB_OUTPUT
          echo "LATEST_MAJOR_MINOR_EE=$LATEST_MAJOR_MINOR_EE" >> $GITHUB_OUTPUT
          
          # Output major.minor
          echo "CE latest major.minor: $LATEST_MAJOR_MINOR_CE"
          echo "EE latest major.minor: $LATEST_MAJOR_MINOR_EE"


      - name: Get latest last_update
        id: latest-last-update
        run: |
          # Get the most recent 'last_updated' for valid release tags
          LATEST_CE_LAST_UPDATE=$(jq -r '.[] | select(.name | test("^[0-9]+\\.[0-9]+\\.[0-9]+-ce\\.0$")) | .last_updated' gitlab_tags_ce.json | sort -V | tail -n 1)
          LATEST_EE_LAST_UPDATE=$(jq -r '.[] | select(.name | test("^[0-9]+\\.[0-9]+\\.[0-9]+-ee\\.0$")) | .last_updated' gitlab_tags_ee.json | sort -V | tail -n 1)

          echo "LATEST_CE_LAST_UPDATE=$LATEST_CE_LAST_UPDATE" >> $GITHUB_OUTPUT
          echo "LATEST_EE_LAST_UPDATE=$LATEST_EE_LAST_UPDATE" >> $GITHUB_OUTPUT
          
          echo "Latest CE last_update: $LATEST_CE_LAST_UPDATE"
          echo "Latest EE last_update: $LATEST_EE_LAST_UPDATE"

      - name: Compare last modified dates
        id: find-update-tags
        run: |
          # Fetch the last saved last modified date for gitlab-ce and gitlab-ee from the file
          saved_ce_last_modified_date=$(cat .github/last_modified_ce_date.txt || echo "")
          saved_ee_last_modified_date=$(cat .github/last_modified_ee_date.txt || echo "")
          
          echo "Last saved modified date for gitlab-ce: $saved_ce_last_modified_date"
          echo "Last saved modified date for gitlab-ee: $saved_ee_last_modified_date"
          
          # If this is the first run, we don't have a saved date, so save the current one
          if [ -z "$saved_ce_last_modified_date" ]; then
            saved_ce_last_modified_date="${{ steps.latest-last-update.outputs.LATEST_CE_LAST_UPDATE }}"
            echo "First run for gitlab-ce, saving last modified date: $saved_ce_last_modified_date"
            echo "$saved_ce_last_modified_date" > .github/last_modified_ce_date.txt
          fi
          
          if [ -z "$saved_ee_last_modified_date" ]; then
            saved_ee_last_modified_date="${{ steps.latest-last-update.outputs.LATEST_EE_LAST_UPDATE }}"
            echo "First run for gitlab-ee, saving last modified date: $saved_ee_last_modified_date"
            echo "$saved_ee_last_modified_date" > .github/last_modified_ee_date.txt
          fi
          
          # Prepare the list of new releases for gitlab-ce
          new_ce_versions="[]"
          for tag_data in $(jq -c '.[]' gitlab_tags_ce.json); do
            tag_name=$(echo "$tag_data" | jq -r '.name')
            tag_last_updated=$(echo "$tag_data" | jq -r '.last_updated')
          
            # Process only valid release tags for gitlab-ce and compare dates
            if [[ "$tag_name" =~ ^[0-9]+\.[0-9]+\.[0-9]+-ce\.0$ ]] && [[ "$tag_last_updated" > "$saved_ce_last_modified_date" ]]; then
          
              major_minor_tag=$(echo "$tag_name" | sed -E "s/-ce.0$//" | cut -d. -f1-2)
              matching_tags=$(grep -E "^${major_minor_tag//./\\.}.*-ce\.0$" own_tags.txt)
              
              # Check if `matching_tags` is empty
              if [[ -z "$matching_tags" ]]; then
                is_newer=true
              else
                is_newer=true
          
                # Check if the tag is the newest
                for tag in $matching_tags; do
                  # Compare the patch version using sort -V (natural sort of versions)
                  if [[ "$(echo -e "$tag_name\n$tag" | sort -V | head -n 1)" != "$tag_name" ]]; then
                    # The tag version is older than a newer tag
                    is_newer=false
                  fi
                done
          
                # Check if the tag already exists and is the same version
                if [[ " $matching_tags " =~ " $tag_name " ]]; then
                  is_newer=false
                fi
              fi
          
              new_ce_versions=$(echo "$new_ce_versions" | jq ". += [{\"tag\": \"$tag_name\", \"is_newest_patch\": $is_newer}]" )
          
              echo "Adding new CE Version: $tag_name"
            fi
          done
          
          echo "New CE versions json: $new_ce_versions"
          
          # Prepare the list of new releases for gitlab-ee
          new_ee_versions="[]"
          for tag_data in $(jq -c '.[]' gitlab_tags_ee.json); do
            tag_name=$(echo "$tag_data" | jq -r '.name')
            tag_last_updated=$(echo "$tag_data" | jq -r '.last_updated')
          
            # Process only valid release tags for gitlab-ee and compare dates
            if [[ "$tag_name" =~ ^[0-9]+\.[0-9]+\.[0-9]+-ee\.0$ ]] && [[ "$tag_last_updated" > "$saved_ee_last_modified_date" ]]; then
          
              major_minor_tag=$(echo "$tag_name" | sed -E "s/-ee.0$//" | cut -d. -f1-2)
              matching_tags=$(grep -E "^${major_minor_tag//./\\.}.*-ce\.0$" own_tags.txt)
    
          
              # Check if `matching_tags` is empty
              if [[ -z "$matching_tags" ]]; then
                is_newer=true
              else
                is_newer=true
          
                # Check if the tag is the newest
                for tag in $matching_tags; do
                  # Compare the patch version using sort -V (natural sort of versions)
                  if [[ "$(echo -e "$tag_name\n$tag" | sort -V | head -n 1)" != "$tag_name" ]]; then
                    # The tag version is older than a newer tag
                    is_newer=false
                  fi
                done
          
                # Check if the tag already exists and is the same version
                if [[ " $matching_tags " =~ " $tag_name " ]]; then
                  is_newer=false
                fi
              fi
          
              # Append to the JSON array
              new_ee_versions=$(echo "$new_ee_versions" | jq ". += [{\"tag\": \"$tag_name\", \"is_newest_patch\": $is_newer}]" )

              # Check for jq errors
              if [ $? -ne 0 ]; then
                echo "Error with jq operation."
                exit 1
              fi

              echo "Adding new EE Version: $tag_name"
            fi
          done
          
          echo "New EE versions json: $new_ee_versions"

          # Save the new last modified date for future runs for gitlab-ce and gitlab-ee
          echo "${{ steps.latest-last-update.outputs.LATEST_CE_LAST_UPDATE }}" > .github/last_modified_ce_date.txt
          echo "${{ steps.latest-last-update.outputs.LATEST_EE_LAST_UPDATE }}" > .github/last_modified_ee_date.txt
          
          # Set output for new versions
          echo "${new_ce_versions}" > new_ce_versions.json
          echo "${new_ee_versions}" > new_ee_versions.json
          
          # if empty "" or contains an empty array "[]"
          if [[ ! -s "new_ce_versions.json" || $(jq 'length == 0' new_ce_versions.json) == "true" ]]; then
            echo "NEW_CE_VERSIONS_AVAILABLE=false" >> $GITHUB_OUTPUT
          else
            echo "NEW_CE_VERSIONS_AVAILABLE=true" >> $GITHUB_OUTPUT
          fi
          
           # if empty "" or contains an empty array "[]"
          if [[ ! -s "new_ee_versions.json" || $(jq 'length == 0' new_ee_versions.json) == "true" ]]; then
            echo "NEW_EE_VERSIONS_AVAILABLE=false" >> $GITHUB_OUTPUT
          else
            echo "NEW_EE_VERSIONS_AVAILABLE=true" >> $GITHUB_OUTPUT
          fi
          

      - name: Trigger build.yml for new CE versions
        if: steps.find-update-tags.outputs.NEW_CE_VERSIONS_AVAILABLE == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const filePath = './new_ce_versions.json';
            
            const newCeVersions = JSON.parse(fs.readFileSync(filePath, 'utf8'));
            const highestCeMajorVersion = '${{ steps.major-version.outputs.LATEST_MAJOR_CE }}';
            const highestCeMajorMinorVersion = '${{ steps.major-version.outputs.LATEST_MAJOR_MINOR_CE }}';
            
            // Trigger workflows for new GitLab CE versions
            newCeVersions.forEach(version => {
              if (version.tag) {
                console.log(`Triggering build for GitLab CE version: ${version.tag}`);
            
                const majorVersion = version.tag.match(/^(\d+)/)[1];
                const majorMinorVersion = version.tag.match(/^(\d+\.\d+)/)[1];
            
                let includeLatestTags = false;
                is_newest_patch=false;
            
                if (version.is_newest_patch) {
                  is_newest_patch=true;
            
                  if (majorMinorVersion === highestCeMajorMinorVersion) {
                    if (majorVersion === highestCeMajorVersion) {
                      includeLatestTags = true;
                    }
                  }
                }
            
                github.rest.actions.createWorkflowDispatch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: "build.yml",
                  ref: "main",
                  inputs: {
                    gitlab_release: version.tag,
                    include_latest_tags: includeLatestTags,
                    include_major_tag: is_newest_patch,
                    include_major_minor_tag: is_newest_patch
                  }
                });
              }
            });


      - name: Trigger build.yml for ee release
        if: steps.find-update-tags.outputs.NEW_EE_VERSIONS_AVAILABLE == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const filePath = './new_ee_versions.json';
            
            const newEeVersions = JSON.parse(fs.readFileSync(filePath, 'utf8'));
            const highestEeMajorVersion = '${{ steps.major-version.outputs.LATEST_MAJOR_EE }}';
            const highestEeMajorMinorVersion = '${{ steps.major-version.outputs.LATEST_MAJOR_MINOR_EE }}';
            
            // Trigger workflows for new GitLab EE versions
            newEeVersions.forEach(version => {
              if (version.tag) {
                console.log(`Triggering build for GitLab EE version: ${version.tag}`);
            
                const majorVersion = version.tag.match(/^(\d+)/)[1];
                const majorMinorVersion = version.tag.match(/^(\d+\.\d+)/)[1];
            
                let includeLatestTags = false;
                is_newest_patch=false;
            
                if (version.is_newest_patch) {
                  is_newest_patch=true;
            
                  if (majorMinorVersion === highestEeMajorMinorVersion) {
                    if (majorVersion === highestEeMajorVersion) {
                      includeLatestTags = true;
                    }
                  }
                }
            
                github.rest.actions.createWorkflowDispatch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: "build.yml",
                  ref: "main",
                  inputs: {
                    gitlab_release: version.tag,
                    include_latest_tags: includeLatestTags,
                    include_major_tag: is_newest_patch,
                    include_major_minor_tag: is_newest_patch
                  }
                });
              }
            });

      - name: Check if files exist
        id: check-files
        run: |
          if [[ -f .github/last_modified_ce_date.txt && -f .github/last_modified_ee_date.txt ]]; then
            echo "files_exist=true" >> $GITHUB_OUTPUT
          else
            echo "files_exist=false" >> $GITHUB_OUTPUT
          fi

      - name: Check CE last_modified_ce_date.txt contents
        run: cat .github/last_modified_ce_date.txt
      - name: Check EE last_modified_ee_date.txt contents
        run: cat .github/last_modified_ee_date.txt

      - name: Commit and Push changes
        if: |
          steps.check-files.outputs.files_exist == 'false' || 
          (
            steps.find-update-tags.outputs.NEW_CE_VERSIONS_AVAILABLE == 'true' ||
            steps.find-update-tags.outputs.NEW_EE_VERSIONS_AVAILABLE == 'true'
          )
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add .github/last_modified_ce_date.txt
          git add .github/last_modified_ee_date.txt

          git commit -m "Update last modified CE date"
          git push